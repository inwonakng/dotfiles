<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>bundleid</key>
	<string>com.github.vanstrouble.alfred.amphetaminedose</string>
	<key>category</key>
	<string>Productivity</string>
	<key>connections</key>
	<dict>
		<key>0B2338A8-DEFB-4B38-B9E8-487A8FEA4D81</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>A1B2265C-5530-4DCB-B35A-7E2208471EA3</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>20400DB6-5F44-4521-89AD-7726D653C199</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>E170A949-67E0-4473-A26B-B085FD7A7758</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>23E12899-365E-4F15-B207-B0CBE97AD3CD</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>20400DB6-5F44-4521-89AD-7726D653C199</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>4746E794-6270-44A3-9508-2FA94F22732A</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>C7BCFF95-48F5-4960-AA21-6BB9DE987967</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>535CE951-9EB5-42FB-B419-12B1FDE6B083</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>0B2338A8-DEFB-4B38-B9E8-487A8FEA4D81</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>6636AAF8-DB5E-4FC1-A0C0-C3A934D7AC73</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>A1B2265C-5530-4DCB-B35A-7E2208471EA3</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>85998765-D8E9-420D-A26F-D1A92E1FE534</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>535CE951-9EB5-42FB-B419-12B1FDE6B083</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
			<dict>
				<key>destinationuid</key>
				<string>EF049EAC-4567-4BDE-8057-D8E5FBE7BF15</string>
				<key>modifiers</key>
				<integer>1048576</integer>
				<key>modifiersubtext</key>
				<string>Allow display sleep</string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>C7BCFF95-48F5-4960-AA21-6BB9DE987967</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>E170A949-67E0-4473-A26B-B085FD7A7758</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>DDAEA08A-F5C9-4DDC-BA0C-1A74F8E2C45D</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>E170A949-67E0-4473-A26B-B085FD7A7758</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
			<dict>
				<key>destinationuid</key>
				<string>FF063610-8F54-4C8A-8B68-79F4CC4CEAEB</string>
				<key>modifiers</key>
				<integer>1048576</integer>
				<key>modifiersubtext</key>
				<string>Allow display sleep</string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>E170A949-67E0-4473-A26B-B085FD7A7758</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>6636AAF8-DB5E-4FC1-A0C0-C3A934D7AC73</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>EF049EAC-4567-4BDE-8057-D8E5FBE7BF15</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>535CE951-9EB5-42FB-B419-12B1FDE6B083</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>FF063610-8F54-4C8A-8B68-79F4CC4CEAEB</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>E170A949-67E0-4473-A26B-B085FD7A7758</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
	</dict>
	<key>createdby</key>
	<string>vanstrouble</string>
	<key>description</key>
	<string>Keep your Mac awake with simple commands.</string>
	<key>disabled</key>
	<false/>
	<key>name</key>
	<string>Amphetamine Dose</string>
	<key>objects</key>
	<array>
		<dict>
			<key>config</key>
			<dict>
				<key>alfredfiltersresults</key>
				<false/>
				<key>alfredfiltersresultsmatchmode</key>
				<integer>0</integer>
				<key>argumenttreatemptyqueryasnil</key>
				<true/>
				<key>argumenttrimmode</key>
				<integer>0</integer>
				<key>argumenttype</key>
				<integer>2</integer>
				<key>escaping</key>
				<integer>102</integer>
				<key>keyword</key>
				<string>{var:amp_keyboard}</string>
				<key>queuedelaycustom</key>
				<integer>3</integer>
				<key>queuedelayimmediatelyinitially</key>
				<true/>
				<key>queuedelaymode</key>
				<integer>0</integer>
				<key>queuemode</key>
				<integer>1</integer>
				<key>runningsubtext</key>
				<string>Please waitâ€¦</string>
				<key>script</key>
				<string>#!/bin/zsh --no-rcs

INPUT="$1"
STATE=$(osascript -e 'tell application "Amphetamine" to return session is active' 2&gt;/dev/null)

if [[ "$STATE" != "true" ]]; then
    echo '{"items":[{"title":"Turn On","subtitle":"Prevent sleep indefinitely","arg":"on","icon":{"path":"icon.png"}}]}'
else
    echo '{"items":[{"title":"Turn Off","subtitle":"Allow computer to sleep","arg":"off","icon":{"path":"icon.png"}}]}'
fi
</string>
				<key>scriptargtype</key>
				<integer>1</integer>
				<key>scriptfile</key>
				<string></string>
				<key>skipuniversalaction</key>
				<true/>
				<key>subtext</key>
				<string>Prevent your computer from going to sleep</string>
				<key>title</key>
				<string>{const:alfred_workflow_name}</string>
				<key>type</key>
				<integer>11</integer>
				<key>withspace</key>
				<false/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.input.scriptfilter</string>
			<key>uid</key>
			<string>DDAEA08A-F5C9-4DDC-BA0C-1A74F8E2C45D</string>
			<key>version</key>
			<integer>3</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>concurrently</key>
				<true/>
				<key>escaping</key>
				<integer>0</integer>
				<key>script</key>
				<string>#!/bin/bash

# Use hotkey_value if provided, otherwise use first argument
INPUT="${hotkey_value:-$1}"

# Default value for display_sleep_allow if not set
display_sleep_allow=${display_sleep_allow:-false}

if [[ "$INPUT" == "off" ]]; then
    osascript -e "tell application \"Amphetamine\" to end session"
    echo "Amphetamine deactivated."
elif [[ "$INPUT" == "on" ]]; then
    # Use display_sleep_allow parameter only when turning on
    osascript -e "tell application \"Amphetamine\" to start new session with options {displaySleepAllowed:$display_sleep_allow}"

    # Use parameter expansion for conditional message
    display_text=""
    [[ "$display_sleep_allow" == "true" ]] &amp;&amp; display_text=" (display can sleep)"
    echo "Amphetamine activated${display_text}."
else
    echo "Error: Invalid input. Use 'on' or 'off'."
    exit 1
fi</string>
				<key>scriptargtype</key>
				<integer>1</integer>
				<key>scriptfile</key>
				<string></string>
				<key>type</key>
				<integer>11</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.action.script</string>
			<key>uid</key>
			<string>6636AAF8-DB5E-4FC1-A0C0-C3A934D7AC73</string>
			<key>version</key>
			<integer>2</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict/>
			<key>type</key>
			<string>alfred.workflow.utility.junction</string>
			<key>uid</key>
			<string>E170A949-67E0-4473-A26B-B085FD7A7758</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>argument</key>
				<string>{query}</string>
				<key>passthroughargument</key>
				<false/>
				<key>variables</key>
				<dict>
					<key>display_sleep_allow</key>
					<string>true</string>
				</dict>
			</dict>
			<key>type</key>
			<string>alfred.workflow.utility.argument</string>
			<key>uid</key>
			<string>FF063610-8F54-4C8A-8B68-79F4CC4CEAEB</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>action</key>
				<integer>0</integer>
				<key>argument</key>
				<integer>0</integer>
				<key>focusedappvariable</key>
				<false/>
				<key>focusedappvariablename</key>
				<string></string>
				<key>leftcursor</key>
				<false/>
				<key>modsmode</key>
				<integer>0</integer>
				<key>relatedAppsMode</key>
				<integer>0</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.trigger.hotkey</string>
			<key>uid</key>
			<string>23E12899-365E-4F15-B207-B0CBE97AD3CD</string>
			<key>version</key>
			<integer>2</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>argument</key>
				<string></string>
				<key>passthroughargument</key>
				<true/>
				<key>variables</key>
				<dict>
					<key>hotkey_value</key>
					<string>on</string>
				</dict>
			</dict>
			<key>type</key>
			<string>alfred.workflow.utility.argument</string>
			<key>uid</key>
			<string>20400DB6-5F44-4521-89AD-7726D653C199</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>lastpathcomponent</key>
				<false/>
				<key>onlyshowifquerypopulated</key>
				<false/>
				<key>removeextension</key>
				<false/>
				<key>text</key>
				<string>{query}</string>
				<key>title</key>
				<string>{const:alfred_workflow_name}</string>
			</dict>
			<key>type</key>
			<string>alfred.workflow.output.notification</string>
			<key>uid</key>
			<string>A1B2265C-5530-4DCB-B35A-7E2208471EA3</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>action</key>
				<integer>0</integer>
				<key>argument</key>
				<integer>0</integer>
				<key>focusedappvariable</key>
				<false/>
				<key>focusedappvariablename</key>
				<string></string>
				<key>leftcursor</key>
				<false/>
				<key>modsmode</key>
				<integer>0</integer>
				<key>relatedAppsMode</key>
				<integer>0</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.trigger.hotkey</string>
			<key>uid</key>
			<string>4746E794-6270-44A3-9508-2FA94F22732A</string>
			<key>version</key>
			<integer>2</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>argument</key>
				<string></string>
				<key>passthroughargument</key>
				<true/>
				<key>variables</key>
				<dict>
					<key>hotkey_value</key>
					<string>off</string>
				</dict>
			</dict>
			<key>type</key>
			<string>alfred.workflow.utility.argument</string>
			<key>uid</key>
			<string>C7BCFF95-48F5-4960-AA21-6BB9DE987967</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>alfredfiltersresults</key>
				<false/>
				<key>alfredfiltersresultsmatchmode</key>
				<integer>0</integer>
				<key>argumenttreatemptyqueryasnil</key>
				<true/>
				<key>argumenttrimmode</key>
				<integer>0</integer>
				<key>argumenttype</key>
				<integer>0</integer>
				<key>escaping</key>
				<integer>102</integer>
				<key>keyword</key>
				<string>{var:ams_keyboard}</string>
				<key>queuedelaycustom</key>
				<integer>3</integer>
				<key>queuedelayimmediatelyinitially</key>
				<true/>
				<key>queuedelaymode</key>
				<integer>0</integer>
				<key>queuemode</key>
				<integer>1</integer>
				<key>runningsubtext</key>
				<string>Please waitâ€¦</string>
				<key>script</key>
				<string>#!/bin/zsh --no-rcs

# Function to calculate the end time based on the given minutes
calculate_end_time() {
    local minutes=$1

    # Check Alfred variable for time format preference
    # 'a' is 12-hour format, 'b' is 24-hour format
    if [[ "${alfred_time_format:-a}" == "a" ]]; then
        # 12-hour format with AM/PM including seconds
        date -v+"$minutes"M +"%l:%M:%S %p" | sed 's/^ //'
    else
        # 24-hour format including seconds
        date -v+"$minutes"M +"%H:%M:%S"
    fi
}

# Function to get the nearest future time based on input hour and minute
get_nearest_future_time() {
    local hour=$1
    local minute=$2
    local current_hour=$3
    local current_minute=$4

    # Calculate current time in minutes since midnight (once instead of twice)
    local current_total=$(( current_hour * 60 + current_minute ))

    # Special handling for hour 12 and conversion to AM/PM using shorter syntax
    local am_hour=$hour
    local pm_hour=$hour
    [[ $hour -eq 12 ]] &amp;&amp; am_hour=0  # 12 AM is actually 0 in 24-hour format
    [[ $hour -lt 12 ]] &amp;&amp; pm_hour=$(( hour + 12 ))

    # Calculate minutes for AM and PM interpretations
    local am_total=$(( am_hour * 60 + minute ))
    local pm_total=$(( pm_hour * 60 + minute ))

    # Calculate differences once
    local am_diff=$(( am_total - current_total ))
    local pm_diff=$(( pm_total - current_total ))

    # Use the same logic but with pre-calculated differences
    if [[ $am_diff -lt 0 &amp;&amp; $pm_diff -gt 0 ]]; then
        echo $pm_diff
    elif [[ $am_diff -gt 0 ]]; then
        echo $am_diff
    else
        echo $(( am_diff + 1440 ))
    fi
}

# Helper function to format hours with leading zero
format_hour() {
    local hour=$1
    # Ensure hour is a number without leading zeros
    hour=${hour#0}
    [[ -z "$hour" ]] &amp;&amp; hour=0
    [[ "$hour" -lt 10 ]] &amp;&amp; echo "0$hour" || echo "$hour"
}

# Helper function to format minutes with leading zero
format_minute() {
    local minute=$1
    # Ensure minute is a number without leading zeros
    minute=${minute#0}
    [[ -z "$minute" ]] &amp;&amp; minute=0
    [[ "$minute" -lt 10 ]] &amp;&amp; echo "0$minute" || echo "$minute"
}

# Helper function to convert AM/PM hour to 24-hour format
convert_to_24h_format() {
    local hour=$1
    local ampm=$2

    # Trim leading zeros
    hour=${hour#0}
    [[ -z "$hour" ]] &amp;&amp; hour=0

    if [[ "$ampm" =~ [pP] &amp;&amp; "$hour" -lt 12 ]]; then
        echo $(( hour + 12 ))
    elif [[ "$ampm" =~ [aA] &amp;&amp; "$hour" -eq 12 ]]; then
        echo 0
    else
        echo $hour
    fi
}

# Helper function to calculate future time from minutes
calculate_future_time() {
    local total_minutes=$1
    local current_hour=$2
    local current_minute=$3

    local future_hour=$(( (total_minutes + current_hour * 60 + current_minute) / 60 % 24 ))
    local future_minute=$(( (total_minutes + current_hour * 60 + current_minute) % 60 ))

    # Format with leading zeros (after removing any existing leading zeros)
    future_hour=$(format_hour "$future_hour")
    future_minute=$(format_minute "$future_minute")

    echo "TIME:$future_hour:$future_minute"
}

# Function to parse the input and calculate the total minutes
parse_input() {
    local input=(${(@s/ /)1})  # Split the input into parts
    local current_hour=$(date +"%H")
    local current_minute=$(date +"%M")

    # Early return for invalid input when empty
    [[ -z "${input[1]}" ]] &amp;&amp; echo "0" &amp;&amp; return

    # Handle single input cases with early returns
    if [[ "${#input[@]}" -eq 1 ]]; then
        # Special value for indefinite mode
        [[ "${input[1]}" == "i" ]] &amp;&amp; echo "indefinite" &amp;&amp; return

        # Format: 2h (hours)
        if [[ "${input[1]}" =~ ^[0-9]+h$ ]]; then
            echo $(( ${input[1]%h} * 60 ))
            return
        fi

        # Direct number input (minutes)
        if [[ "${input[1]}" =~ ^[0-9]+$ ]]; then
            echo "${input[1]}"
            return
        fi

        # Format: 8 or 8: (hour only)
        if [[ "${input[1]}" =~ ^([0-9]{1,2}):?$ ]]; then
            local hour=${match[1]}
            local minute=0

            # Parameter expansion is more efficient than sed
            hour=${hour#0}

            # Check if the input has a colon at the end
            if [[ "${input[1]}" =~ :$ ]]; then
                # If it has a colon, calculate specific time
                local total_minutes=$(get_nearest_future_time "$hour" "$minute" "$current_hour" "$current_minute")

                # Use helper function to calculate future time
                local future_time=$(calculate_future_time "$total_minutes" "$current_hour" "$current_minute")
                # For hour-only format with colon, we want to force minutes to 00
                echo "${future_time%:*}:00"
            else
                # No colon, return minutes
                local total_minutes=$(get_nearest_future_time "$hour" "$minute" "$current_hour" "$current_minute")
                echo "$total_minutes"
            fi
            return
        fi

        # Format: 8a, 8am, 8p, 8pm
        if [[ "${input[1]}" =~ ^([0-9]{1,2})([aApP])?(m)?$ ]]; then
            local hour=${match[1]}
            local ampm=${match[2]:-""}
            local minute=0

            # With AM/PM indicator
            if [[ -n "$ampm" ]]; then
                # Convert to 24-hour format using helper function
                hour=$(convert_to_24h_format "$hour" "$ampm")

                # Format hour with leading zero
                hour=$(format_hour "$hour")
                echo "TIME:$hour:00"
            else
                # Without AM/PM, use nearest future time
                hour=${hour#0}
                echo $(get_nearest_future_time "$hour" "$minute" "$current_hour" "$current_minute")
            fi
            return
        fi

        # Format: 8:30, 8:30a, 8:30am, 8:30p, 8:30pm
        if [[ "${input[1]}" =~ ^([0-9]{1,2}):([0-9]{1,2})([aApP])?([mM])?$ ]]; then
            local hour=${match[1]}
            local minute=${match[2]}
            local ampm=${match[3]:-""}

            # With AM/PM indicator
            if [[ -n "$ampm" ]]; then
                # Convert to 24-hour format using helper function
                hour=$(convert_to_24h_format "$hour" "$ampm")

                # Format output with leading zeros
                hour=$(format_hour "$hour")
                minute=$(format_minute "$minute")
                echo "TIME:$hour:$minute"
            else
                # Without explicit AM/PM, calculate future time
                hour=${hour#0}
                local total_minutes=$(get_nearest_future_time "$hour" "$minute" "$current_hour" "$current_minute")

                # Use helper function to calculate and format future time
                echo $(calculate_future_time "$total_minutes" "$current_hour" "$current_minute")
            fi
            return
        fi

        # If we get here, it's an invalid single input
        echo "0"
        return
    fi

    # Handle two-part input (hours and minutes)
    if [[ "${#input[@]}" -eq 2 ]]; then
        if [[ "${input[1]}" =~ ^[0-9]+$ &amp;&amp; "${input[2]}" =~ ^[0-9]+$ ]]; then
            echo $(( input[1] * 60 + input[2] ))
            return
        fi

        # Invalid two-part input
        echo "0"
        return
    fi

    # Default case: invalid input
    echo "0"
}

# Function to format the duration in hours and minutes
format_duration() {
    local total_minutes=$1
    local hours=$(( total_minutes / 60 ))
    local minutes=$(( total_minutes % 60 ))

    if [[ "$hours" -gt 0 &amp;&amp; "$minutes" -gt 0 ]]; then
        echo "$hours hour(s) $minutes minute(s)"
    elif [[ "$hours" -gt 0 ]]; then
        echo "$hours hour(s)"
    else
        echo "$minutes minute(s)"
    fi
}

# Function to generate Alfred JSON output
generate_output() {
    local input_result=$1

    # Check for invalid input first (fastest check)
    if [[ "$input_result" == "0" ]]; then
        echo '{"items":[{"title":"Invalid input","subtitle":"Please provide a valid time format","arg":"0","icon":{"path":"icon.png"}}]}'
        return
    fi

    # Check for indefinite mode (no rerun needed)
    if [[ "$input_result" == "indefinite" ]]; then
        echo '{"items":[{"title":"Active indefinitely","subtitle":"Keep your Mac awake until manually disabled","arg":"indefinite","icon":{"path":"icon.png"}}]}'
        return
    fi

    # Check for target time format
    if [[ "$input_result" == TIME:* ]]; then
        local target_time=${input_result#TIME:}
        local hour=${target_time%:*}
        local minute=${target_time#*:}

        # To display the time in a user-friendly format
        local display_time=$(date -j -f "%H:%M" "$target_time" "+%l:%M %p" 2&gt;/dev/null | sed 's/^ //')
        [[ $? -ne 0 ]] &amp;&amp; display_time="$target_time"

        echo '{"items":[{"title":"Active until '"$display_time"'","subtitle":"Keep awake until specified time","arg":"'"$input_result"'","icon":{"path":"icon.png"}}]}'
        return
    fi

    # Finally, handle duration in minutes (most common case)
    local end_time=$(calculate_end_time "$input_result")
    local formatted_duration=$(format_duration "$input_result")
    echo '{"rerun":1,"items":[{"title":"Active for '"$formatted_duration"'","subtitle":"Keep awake until around '"$end_time"'","arg":"'"$input_result"'","icon":{"path":"icon.png"}}]}'
}

# Main function
main() {
    local total_minutes=$(parse_input "$1")
    generate_output "$total_minutes"
}

# Execute the main function with the input
main "$1"
</string>
				<key>scriptargtype</key>
				<integer>1</integer>
				<key>scriptfile</key>
				<string></string>
				<key>subtext</key>
				<string>Define the time</string>
				<key>title</key>
				<string>Active for {query}</string>
				<key>type</key>
				<integer>11</integer>
				<key>withspace</key>
				<true/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.input.scriptfilter</string>
			<key>uid</key>
			<string>85998765-D8E9-420D-A26F-D1A92E1FE534</string>
			<key>version</key>
			<integer>3</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>concurrently</key>
				<true/>
				<key>escaping</key>
				<integer>68</integer>
				<key>script</key>
				<string>#!/bin/bash

# Function to calculate the end time based on the given minutes
calculate_end_time() {
    local minutes=$1

    # Check Alfred variable for time format preference
    if [[ "${alfred_time_format:-a}" == "a" ]]; then
        # 12-hour format with AM/PM
        date -v+"$minutes"M +"%l:%M %p" | sed 's/^ //'
    else
        # 24-hour format
        date -v+"$minutes"M +"%H:%M"
    fi
}

# Function to extract hour and minute from TIME:HH:MM format
parse_time_format() {
    local time_str=$1

    # Remove the TIME: prefix
    time_str=${time_str#TIME:}

    # Extract hour and minute directly
    local hour=${time_str%%:*}
    local minute=${time_str#*:}

    # Validate input - purely numeric and in range
    if [[ ! "$hour" =~ ^[0-9]+$ || ! "$minute" =~ ^[0-9]+$ || "$hour" -gt 23 || "$minute" -gt 59 ]]; then
        echo "Error: Invalid time format: $time_str" &gt;&amp;2
        exit 1
    fi

    # Return as space-separated values
    echo "$hour $minute"
}

# Function to calculate minutes until target time
calculate_minutes_until_target() {
    local hour=$1
    local minute=$2

    # Get current time
    local current_hour=$(date +"%H")
    local current_minute=$(date +"%M")

    # Calculate total minutes
    local target_minutes=$(( hour * 60 + minute ))
    local current_minutes=$(( current_hour * 60 + current_minute ))
    local duration_minutes=$(( target_minutes - current_minutes ))

    # If target time is earlier than current time, add 24 hours
    [[ $duration_minutes -le 0 ]] &amp;&amp; duration_minutes=$(( duration_minutes + 1440 ))

    echo "$duration_minutes"
}

# Function to format time for display
format_display_time() {
    local hour=$1
    local minute=$2
    local time_format=${3:-a}

    local display_time

    if [[ "$time_format" == "a" ]]; then
        # 12-hour format
        if [[ "$hour" -gt 12 ]]; then
            display_time="$((hour-12)):${minute} PM"
        elif [[ "$hour" -eq 12 ]]; then
            display_time="12:${minute} PM"
        elif [[ "$hour" -eq 0 ]]; then
            display_time="12:${minute} AM"
        else
            display_time="${hour}:${minute} AM"
        fi

        # Ensure minutes have leading zero if needed
        [[ ${#minute} -eq 1 ]] &amp;&amp; display_time="${display_time/\:$minute/\:0$minute}"
    else
        # 24-hour format
        [[ ${#hour} -eq 1 ]] &amp;&amp; hour="0$hour"
        [[ ${#minute} -eq 1 ]] &amp;&amp; minute="0$minute"
        display_time="${hour}:${minute}"
    fi

    echo "$display_time"
}

# Function to print output message based on display sleep setting
output_message() {
    local message=$1
    local approximate=$2
    local allow_display_sleep=$3

    local prefix="Keeping awake"
    local suffix

    if [[ "$allow_display_sleep" == "true" ]]; then
        suffix=". (Display can sleep)"
    else
        suffix="."
    fi

    if [[ -n "$approximate" &amp;&amp; "$approximate" == "true" ]]; then
        echo "${prefix} until around ${message}${suffix}"
    else
        echo "${prefix} until ${message}${suffix}"
    fi
}

# Function to print indefinite output message based on display sleep setting
output_indefinite_message() {
    local allow_display_sleep=$1

    if [[ "$allow_display_sleep" == "true" ]]; then
        echo "Keeping awake indefinitely. (Display can sleep)"
    else
        echo "Keeping awake indefinitely."
    fi
}

# Function to start an Amphetamine session with minutes
start_amphetamine_session() {
    local total_minutes=$1
    local allow_display_sleep=$2

    # Ensure the minutes are a valid number and greater than 0
    if [[ ! "$total_minutes" =~ ^[0-9]+$ || "$total_minutes" -eq 0 ]]; then
        echo "Error: Invalid duration: $total_minutes minutes" &gt;&amp;2
        exit 1
    fi

    osascript -e "tell application \"Amphetamine\" to start new session with options {duration:$total_minutes, interval:minutes, displaySleepAllowed:$allow_display_sleep}" || {
        echo "Error: Failed to start Amphetamine session." &gt;&amp;2
        exit 1
    }
}

# Function to start an indefinite Amphetamine session
start_indefinite_session() {
    local allow_display_sleep=$1

    osascript -e "tell application \"Amphetamine\" to start new session with options {displaySleepAllowed:$allow_display_sleep}" || {
        echo "Error: Failed to start Amphetamine session." &gt;&amp;2
        exit 1
    }

    output_indefinite_message "$allow_display_sleep"
}

# Function to handle target time input
handle_target_time() {
    local target_time=$1
    local allow_display_sleep=$2

    # Extract hour and minute
    read -r hour minute &lt;&lt;&lt; "$(parse_time_format "$target_time")"

    # Calculate minutes until target time
    local duration_minutes=$(calculate_minutes_until_target "$hour" "$minute")

    # Start the session
    start_amphetamine_session "$duration_minutes" "$allow_display_sleep"

    # Format time for display
    local display_time=$(format_display_time "$hour" "$minute" "${alfred_time_format:-a}")

    # Output result message
    output_message "$display_time" "false" "$allow_display_sleep"
}

# Function to handle minute duration input
handle_duration() {
    local minutes=$1
    local allow_display_sleep=$2

    # Calculate end time for display
    local end_time=$(calculate_end_time "$minutes")

    # Start the session
    start_amphetamine_session "$minutes" "$allow_display_sleep"

    # Output result message using the common function
    output_message "$end_time" "true" "$allow_display_sleep"
}

# Main function
main() {
    # Default value for display_sleep_allow if not set
    display_sleep_allow=${display_sleep_allow:-false}

    # Handle different input types from the Filter Script
    if [[ "$INPUT" == "0" ]]; then
        echo "Error: Invalid input. Please provide a valid duration."
        exit 1
    elif [[ "$INPUT" == "indefinite" ]]; then
        start_indefinite_session "$display_sleep_allow"
    elif [[ "$INPUT" == TIME:* ]]; then
        handle_target_time "$INPUT" "$display_sleep_allow"
    elif [[ "$INPUT" =~ ^[0-9]+$ ]]; then
        handle_duration "$INPUT" "$display_sleep_allow"
    fi
}

INPUT="$1"
main</string>
				<key>scriptargtype</key>
				<integer>1</integer>
				<key>scriptfile</key>
				<string></string>
				<key>type</key>
				<integer>11</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.action.script</string>
			<key>uid</key>
			<string>0B2338A8-DEFB-4B38-B9E8-487A8FEA4D81</string>
			<key>version</key>
			<integer>2</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict/>
			<key>type</key>
			<string>alfred.workflow.utility.junction</string>
			<key>uid</key>
			<string>535CE951-9EB5-42FB-B419-12B1FDE6B083</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>argument</key>
				<string>{query}</string>
				<key>passthroughargument</key>
				<false/>
				<key>variables</key>
				<dict>
					<key>display_sleep_allow</key>
					<string>true</string>
				</dict>
			</dict>
			<key>type</key>
			<string>alfred.workflow.utility.argument</string>
			<key>uid</key>
			<string>EF049EAC-4567-4BDE-8057-D8E5FBE7BF15</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
	</array>
	<key>readme</key>
	<string># Amphetamine Dose | Alfred Workflow

A simple workflow that integrates with the [Amphetamine app](https://apps.apple.com/us/app/amphetamine/id937984704?mt=12) to keep your Mac awake. This workflow allows you to activate or deactivate Amphetamine and set it to stay awake for a specified duration or until a specific time, all from within Alfred.

## Getting Started

### Toggle Amphetamine (dose)

Use the `dose` keyword to toggle Amphetamine on or off, preventing macOS from sleeping.

**Keyword:** `dose`

If you hold the Command key while using the `dose` command, the session will allow the display to sleep.

### One command for everything (ams)

The `ams` command allows you to set Amphetamine to keep your Mac awake for a specific duration or until a specific time. It supports natural input formats for minutes, hours, and specific times, making it flexible and easy to use.

**Keyword:** `ams [duration or time]`

If you hold the Command key while using the `ams` command, the session will allow the display to sleep.

**Examples**:
- `ams 15`: Keeps your Mac awake for 15 minutes.
- `ams 1 30`: Keeps your Mac awake for 1 hour and 30 minutes.
- `ams 2h`: Keeps your Mac awake for 2 hours.
- `ams 8am`: Keeps your Mac awake until 8:00 AM.
- `ams 9:30`: Keeps your Mac awake until the next 9:30.
- `ams 11:40pm`: Keeps your Mac awake until 11:40 PM.

The `ams` command supports both 12-hour (AM/PM) and 24-hour time formats.

---

Created by **Pedro VÃ¡zquez** (vanstrouble).</string>
	<key>uidata</key>
	<dict>
		<key>0B2338A8-DEFB-4B38-B9E8-487A8FEA4D81</key>
		<dict>
			<key>xpos</key>
			<real>525</real>
			<key>ypos</key>
			<real>400</real>
		</dict>
		<key>20400DB6-5F44-4521-89AD-7726D653C199</key>
		<dict>
			<key>note</key>
			<string>Turn On</string>
			<key>xpos</key>
			<real>270</real>
			<key>ypos</key>
			<real>160</real>
		</dict>
		<key>23E12899-365E-4F15-B207-B0CBE97AD3CD</key>
		<dict>
			<key>note</key>
			<string>Turn On Hotkey</string>
			<key>xpos</key>
			<real>30</real>
			<key>ypos</key>
			<real>130</real>
		</dict>
		<key>4746E794-6270-44A3-9508-2FA94F22732A</key>
		<dict>
			<key>note</key>
			<string>Turn Off Hotkey</string>
			<key>xpos</key>
			<real>30</real>
			<key>ypos</key>
			<real>265</real>
		</dict>
		<key>535CE951-9EB5-42FB-B419-12B1FDE6B083</key>
		<dict>
			<key>xpos</key>
			<real>415</real>
			<key>ypos</key>
			<real>430</real>
		</dict>
		<key>6636AAF8-DB5E-4FC1-A0C0-C3A934D7AC73</key>
		<dict>
			<key>xpos</key>
			<real>530</real>
			<key>ypos</key>
			<real>15</real>
		</dict>
		<key>85998765-D8E9-420D-A26F-D1A92E1FE534</key>
		<dict>
			<key>xpos</key>
			<real>30</real>
			<key>ypos</key>
			<real>400</real>
		</dict>
		<key>A1B2265C-5530-4DCB-B35A-7E2208471EA3</key>
		<dict>
			<key>xpos</key>
			<real>720</real>
			<key>ypos</key>
			<real>215</real>
		</dict>
		<key>C7BCFF95-48F5-4960-AA21-6BB9DE987967</key>
		<dict>
			<key>note</key>
			<string>Turn Off</string>
			<key>xpos</key>
			<real>265</real>
			<key>ypos</key>
			<real>295</real>
		</dict>
		<key>DDAEA08A-F5C9-4DDC-BA0C-1A74F8E2C45D</key>
		<dict>
			<key>xpos</key>
			<real>30</real>
			<key>ypos</key>
			<real>15</real>
		</dict>
		<key>E170A949-67E0-4473-A26B-B085FD7A7758</key>
		<dict>
			<key>xpos</key>
			<real>420</real>
			<key>ypos</key>
			<real>45</real>
		</dict>
		<key>EF049EAC-4567-4BDE-8057-D8E5FBE7BF15</key>
		<dict>
			<key>xpos</key>
			<real>265</real>
			<key>ypos</key>
			<real>485</real>
		</dict>
		<key>FF063610-8F54-4C8A-8B68-79F4CC4CEAEB</key>
		<dict>
			<key>xpos</key>
			<real>270</real>
			<key>ypos</key>
			<real>95</real>
		</dict>
	</dict>
	<key>userconfigurationconfig</key>
	<array>
		<dict>
			<key>config</key>
			<dict>
				<key>default</key>
				<string>dose</string>
				<key>placeholder</key>
				<string></string>
				<key>required</key>
				<false/>
				<key>trim</key>
				<true/>
			</dict>
			<key>description</key>
			<string>Switch the workflow on or off via keyboard input.</string>
			<key>label</key>
			<string>Keyboard Toggle Control</string>
			<key>type</key>
			<string>textfield</string>
			<key>variable</key>
			<string>amp_keyboard</string>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>default</key>
				<string>ams</string>
				<key>placeholder</key>
				<string></string>
				<key>required</key>
				<false/>
				<key>trim</key>
				<true/>
			</dict>
			<key>description</key>
			<string>Use the keyboard to set a custom wake duration or time.</string>
			<key>label</key>
			<string>Activate Wake Timer</string>
			<key>type</key>
			<string>textfield</string>
			<key>variable</key>
			<string>ams_keyboard</string>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>default</key>
				<string>a</string>
				<key>pairs</key>
				<array>
					<array>
						<string>12-hour (AM/PM)</string>
						<string>a</string>
					</array>
					<array>
						<string>24-hour</string>
						<string>b</string>
					</array>
				</array>
			</dict>
			<key>description</key>
			<string>Set your preferred time display: 12-hour (AM/PM) or 24-hour format.</string>
			<key>label</key>
			<string>Time Format Selection</string>
			<key>type</key>
			<string>popupbutton</string>
			<key>variable</key>
			<string>alfred_time_format</string>
		</dict>
	</array>
	<key>variables</key>
	<dict>
		<key>workflow_name</key>
		<string>{const:alfred_workflow_name}</string>
	</dict>
	<key>variablesdontexport</key>
	<array/>
	<key>version</key>
	<string>2.1.7</string>
	<key>webaddress</key>
	<string>https://github.com/vanstrouble/dose-alfred-workflow.git</string>
</dict>
</plist>
